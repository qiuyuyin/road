## å¯†ç åŠ å¯†

![image-20220124000713258](https://yili979.oss-cn-beijing.aliyuncs.com/img/image-20220124000713258.png)

>   ä½ è¿˜åœ¨ä½¿ç”¨MD5æ¥å¯¹æ•°æ®è¿›è¡ŒåŠ å¯†å—ï¼Œæˆ–è€…ç›´æ¥å°†ç”¨æˆ·å¯†ç åŸå°ä¸åŠ¨æ”¾åœ¨æ•°æ®åº“ä¸­å—ï¼Ÿé‚£ä¹ˆä½ çš„ç³»ç»Ÿå¯èƒ½ä¼šæˆä¸ºä¸‹ä¸€ä¸ªFacebookï¼Œä½¿å¾—æˆåƒä¸Šä¸‡çš„ç”¨æˆ·ä¿¡æ¯æ³„æ¼ã€‚

æœ€è¿‘é‡æ„é¡¹ç›®ä½¿å¾—æˆ‘é‡æ–°å®¡è§†äº†ä¸€ä¸‹ä¹‹å‰å¯¹åº”ç”¨çš„åŠ å¯†æ–¹å¼ï¼Œå°±æ˜¯ç›´æ¥ä½¿ç”¨MD5å°†æ•°æ®è¿›è¡Œä¸€æ¬¡Hashï¼Œç„¶è€Œç°åœ¨çš„MD5æ—©å°±ä¸æ˜¯ä¸€ä¸ªå®‰å…¨çš„åŠ å¯†æ–¹å¼äº†ã€‚

![image-20220124001009699](https://yili979.oss-cn-beijing.aliyuncs.com/img/image-20220124001009699.png)

æ‰€ä»¥åœ¨å¯¹é¡¹ç›®é‡æ„ä¸­ï¼Œæˆ‘æ‰“ç®—ä½¿ç”¨æ›´ä¸ºå®‰å…¨çš„SHA-256çš„åŠ å¯†æ–¹å¼ï¼š

![image-20220124000951544](https://yili979.oss-cn-beijing.aliyuncs.com/img/image-20220124000951544.png)

é‚£ä¹ˆå°±æ¥çœ‹ä¸€çœ‹å¦‚ä½•ä½¿ç”¨golangæ¥å¯¹ä¸€æ®µå¯†ç å­—ç¬¦ä¸²è¿›è¡ŒåŠ å¯†æ“ä½œå§ï¼

é¦–å…ˆgolangæ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ç³»åˆ—çš„ç®—æ³•æ¥è¿›è¡ŒåŠ å¯†æ“ä½œï¼Œé¦–å…ˆæ˜¯åŸºç¡€çš„åŠ å¯†åº“

æ¯”å¦‚å¦‚æœæƒ³è¦ä½¿ç”¨sha256ï¼Œç›´æ¥è°ƒç”¨æ ‡å‡†åº“å°±å¯ä»¥ç›´æ¥å¾—åˆ°ç»“æœï¼š

```go
package main

import (
    "crypto/sha256"
    "fmt"
)

func main() {
    h := sha256.New()
    h.Write([]byte("hello world\n"))
    fmt.Printf("%x", h.Sum(nil))
}
```

ä½†æ˜¯ç”±äºSHA-256ä»ç„¶æ— æ³•é¿å…é€šè¿‡ğŸŒˆå½©è™¹è¡¨çš„å½¢å¼æ¥åæ¨å¾—åˆ°Hashä¹‹å‰çš„å€¼ï¼Œæ‰€ä»¥Golangåˆæä¾›äº†ä¸€äº›ç°æˆçš„æ–¹å¼ï¼ˆå¯†ç å¤§ç‰›ç ”ç©¶å‡ºæ¥çš„ä¸€äº›æ›´é«˜å±‚æ¬¡çš„ç®—æ³•ï¼‰ï¼š

>   golangå®˜æ–¹å°†ä¸€äº›æ–°ç‰¹æ€§çš„åŠŸèƒ½æ”¾åœ¨äº†golang.org/xçš„åŒ…ä¸‹ï¼ˆåŸå› æ˜¯å¯èƒ½æ— æ³•å‘å‰å…¼å®¹è¿‡å¤šç‰ˆæœ¬ï¼ŒåŒæ—¶å¯èƒ½å­˜åœ¨ä¸€å®šçš„BUGï¼‰

![image-20220124145946001](https://yili979.oss-cn-beijing.aliyuncs.com/img/image-20220124145946001.png)

è¿™äº›ç®—æ³•æ˜¯åŸºäºåŸºç¡€çš„Hashæ¥é’ˆå¯¹æ€§çš„ä¼˜åŒ–ï¼Œä»¥å¾—åˆ°æ›´å¥½çš„ç»“æœã€‚

è¿™é‡Œæˆ‘æ‰“ç®—é‡‡ç”¨Bcryptç®—æ³•æ¥å¯¹å¯†ç è¿›è¡ŒåŠ å¯†æ“ä½œï¼š

æ ‡å‡†åº“ä¸­å­˜åœ¨ç€Bcryptæ‰€æä¾›çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨è¿›è¡Œè°ƒç”¨æ“ä½œã€‚

```go
// GenerateFromPassword returns the bcrypt hash of the password at the given
// cost. If the cost given is less than MinCost, the cost will be set to
// DefaultCost, instead. Use CompareHashAndPassword, as defined in this package,
// to compare the returned hashed password with its cleartext version.
func GenerateFromPassword(password []byte, cost int) ([]byte, error) {
   p, err := newFromPassword(password, cost)
   if err != nil {
      return nil, err
   }
   return p.Hash(), nil
}

// CompareHashAndPassword compares a bcrypt hashed password with its possible
// plaintext equivalent. Returns nil on success, or an error on failure.
func CompareHashAndPassword(hashedPassword, password []byte) error {
   p, err := newFromHash(hashedPassword)
   if err != nil {
      return err
   }

   otherHash, err := bcrypt(password, p.cost, p.salt)
   if err != nil {
      return err
   }

   otherP := &hashed{otherHash, p.salt, p.cost, p.major, p.minor}
   if subtle.ConstantTimeCompare(p.Hash(), otherP.Hash()) == 1 {
      return nil
   }

   return ErrMismatchedHashAndPassword
}
```

ç„¶åç¼–å†™ä¸€ä¸ªæµ‹è¯•ç±»æ¥è¿›è¡Œæµ‹è¯•ï¼š

```go
package test

import (
    "fmt"
    "golang.org/x/crypto/bcrypt"
    "log"
    "testing"
)

func TestHash(t *testing.T) {
    // è¾“å…¥å¯†ç  è·å– hash å€¼
    pwd := []byte("123456")
    hash := hashAndSalt(pwd)
    // å†æ¬¡è¾“å…¥å¯†ç éªŒè¯
    pwd2 := []byte("123456")
    pwdMatch := comparePasswords(hash, pwd2)
    fmt.Println("Passwords Match?", pwdMatch)
}


func hashAndSalt(pwd []byte) string {
    hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
    log.Println("hash:",string(hash))
    if err != nil {
        log.Println(err)
    }
    return string(hash)
}

func comparePasswords(hashedPwd string, plainPwd []byte) bool {
    byteHash := []byte(hashedPwd)

    err := bcrypt.CompareHashAndPassword(byteHash, plainPwd)
    if err != nil {
        log.Println(err)
        return false
    }
    return true
}
```

è¿™æ ·å°±ä»…ä»…èŠ±è´¹æ•°è¡Œä»£ç å°±å®ç°äº†ä¸€ä¸ªå·¨å¤§çš„ç—›ç‚¹ï¼
